//! Handler for static files.

mod file;
mod mime_extension;
mod util;

use std::{collections::HashMap, io, path::PathBuf, process};

use file::File;
use snowboard::{response, Response, ResponseLike};
use util::{get_paths, invalid_utf8_detected};

use crate::{error, info, success};

/// Path to the static files generated by the frontend.
pub const DIST: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/../web/dist");

pub struct StaticFileHandler {
	root: PathBuf,
	cached_files: HashMap<String, File>,
	fallback: Option<File>,
	default_extension: Option<&'static str>,
}

impl StaticFileHandler {
	/// Creates a new `StaticFileHandler` with the given root directory.
	pub fn new(root: &str) -> Self {
		Self {
			root: PathBuf::from(root),
			cached_files: HashMap::new(),
			fallback: None,
			default_extension: None,
		}
	}

	/// Runs [`Self::init`] and exits the process if it fails.
	pub fn expect_init() -> Self {
		Self::init().unwrap_or_else(|err| {
			error!("Failed to load static files: {}", err);
			process::exit(1);
		})
	}

	/// Initializes a new `StaticFileHandler` with the default root directory,
	/// `index.html` as the default index file and `404.html` as the default
	/// 404 file.
	pub fn init() -> io::Result<StaticFileHandler> {
		let mut handler = StaticFileHandler::new(DIST);
		info!("Loading static files in '{}'...", handler.root());
		let files = handler.load()?;
		handler.set_index("index.html")?;
		handler.set_fallback("404.html")?;
		handler.set_default_extension("html");

		success!("Loaded {} files", files);
		Ok(handler)
	}

	/// Loads all the files from `self.root` and caches them.
	/// Returns the number of files loaded.
	pub fn load(&mut self) -> io::Result<usize> {
		let paths = get_paths(&self.root)?;

		for path in paths {
			let cloned = path.clone();
			self.cached_files.insert(
				path.to_str()
					.ok_or_else(|| invalid_utf8_detected(&cloned))?
					// Remove the root from the path and skip the first '/'
					.replace(self.root(), "")[1..]
					.into(),
				File::try_from(cloned)?,
			);
		}

		Ok(self.cached_files.len())
	}

	/// Returns the root directory of the static files, as a `&str`.
	pub fn root(&self) -> &str {
		// SAFETY: We know `self.root` is valid UTF-8 because we
		// get is as a `&str` in [`Self::new`]
		self.root.to_str().unwrap()
	}

	/// Sets a default path to redirect to when the path is an empty string.
	pub fn set_index(&mut self, path: &str) -> io::Result<()> {
		self.cached_files
			.insert(String::new(), File::try_from(self.root.join(path))?);

		Ok(())
	}

	/// Sets a fallback path to redirect to when the path is not found.
	pub fn set_fallback(&mut self, path: &str) -> io::Result<()> {
		self.fallback = Some(File::try_from(self.root.join(path))?);
		Ok(())
	}

	/// Sets a default file extension so that if the requested path does not exist,
	/// the handler will try to find a file with the same name but with the given
	/// extension. (e.g converting `/about` to `/about.html` if `/about` does not exist)
	///
	/// # Warning
	/// Do not include `.` at the start of the extension (unless you want it to have 2 consecutive dots).
	pub fn set_default_extension(&mut self, ext: &'static str) {
		self.default_extension = Some(ext);
	}

	/// The same as [`Self::get_file`], but converts it to a response if found.
	pub fn get_response(&self, path: &str) -> Option<Response> {
		self.get_file(path).map(|file| file.to_response())
	}

	/// Tries to get the file set to the given path.
	///
	/// # Warning
	/// Do not include `/` at the start of the path. It will not be found.
	pub fn get_file(&self, path: &str) -> Option<&File> {
		if let Some(extension) = self.default_extension.as_ref() {
			self.cached_files
				.get(path)
				.or_else(|| self.cached_files.get(&format!("{}.{}", path, extension)))
		} else {
			self.cached_files.get(path)
		}
	}

	/// Returns the file at the given path, or the fallback file if it is not
	/// found. If no fallback is set, returns an empty 404 response. See
	/// [`Self::get_file`].
	pub fn get_response_or_404(&self, path: &str) -> Response {
		if let Some(fallback) = &self.fallback {
			self.get_response(path).unwrap_or(fallback.to_response())
		} else {
			response!(not_found)
		}
	}
}
